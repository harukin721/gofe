//
// 深さ優先探索には、先行順、中間順、後行順の3つの方法がある
//
// 先行順
// 1. 自身の処理（節番号を出力）
// 2. 左の子の節に対して手続 order を再帰的に呼び出す
// 3. 右の子の節に対して手続 order を再帰的に呼び出す
//
// 中間順
// 1. 左の子の節に対して手続 order を再帰的に呼び出す
// 2. 自身の処理（節番号を出力）
// 3. 右の子の節に対して手続 order を再帰的に呼び出す
//
// 後行順
// 1. 左の子の節に対して手続 order を再帰的に呼び出す
// 2. 右の子の節に対して手続 order を再帰的に呼び出す
// 3. 自身の処理（節番号を出力）

package main

import "fmt"

// tree は整数型配列の配列
var tree = [][]int{
	// 1 が根
	// 2 が左部分木の根、3 が右部分木の根
	// 4 が左部分木の左部分木の根、5 が左部分木の右部分木の根
	// 6 が右部分木の左部分木の根、7 が右部分木の右部分木の根
	// 8 が左部分木の左部分木の左部分木の根、9 が左部分木の右部分木の右部分木の根
	// 10 が右部分木の左部分木の左部分木の根、11 が右部分木の右部分木の右部分木の根
	// 12 が左部分木の左部分木の右部分木の根、13 が右部分木の左部分木の右部分木の根
	// 14 が右部分木の右部分木の右部分木の根
	{2, 3}, {4, 5}, {6, 7}, {8, 9},
	{10, 11}, {12, 13}, {14}, {}, {}, {},
	{}, {}, {}, {},
}

// order は指定したノードを根とする部分木を走査し、すべてのノード番号を出力
func order(n int) {
	// 配列 tree の要素数が 2 の場合は、そのノードは左部分木と右部分木が存在
	if len(tree[n-1]) == 2 {
		// 左部分木を走査
		order(tree[n-1][0])
		// ノード番号を出力
		fmt.Println(n)
		// 右部分木を走査
		order(tree[n-1][1])
	// 配列 tree の要素数が 1 の場合は、そのノードは左部分木のみ存在
	} else if len(tree[n-1]) == 1 {
		// 左部分木を走査
		order(tree[n-1][0])
		// ノード番号を出力
		fmt.Println(n)
	// 配列 tree の要素数が 0 の場合は、そのノードは存在しない
	} else {
		// ノード番号を出力
		fmt.Println(n)
	}
}

func main() {
	// 2分木の走査を根から行う
	order(1)
}

// 出力
// 8, 4, 9, 2, 10, 5, 11, 1, 12, 6, 13, 3, 14, 7
